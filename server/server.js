// Multiplayer Game Server (WebSocket)
// Run with: node server/server.js

const WebSocket = require('ws');
const { v4: uuidv4 } = require('uuid');

const path = require('path');
const { EnemyWaveManagerCore } = require(path.resolve(__dirname, '../dist/shared/EnemyWaveManagerCore.js'));
const PORT = 3001;
const wss = new WebSocket.Server({ port: PORT });

// Collision dimensions (moved to top-level global scope)
const PLAYER_WIDTH = 40, PLAYER_HEIGHT = 40;
const ENEMY_WIDTH = 40, ENEMY_HEIGHT = 40;
const BULLET_WIDTH = 8, BULLET_HEIGHT = 16;

const COLORS = [
  '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231',
  '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe',
  '#008080', '#e6beff', '#9a6324', '#fffac8', '#800000',
  '#aaffc3', '#808000', '#ffd8b1', '#000075', '#808080'
];

let players = {}; // id: { ws, color, x, y, lives, velocityX, velocityY, lastInputTime, input: { left, right, up, down, fire } }
let playerBullets = []; // { id, x, y, velocityY, ownerId }
let enemyBullets = []; // { id, x, y, velocityX, velocityY, ownerId: 'enemy_<id>' }
let usedColors = new Set();
const enemyWaveManager = new EnemyWaveManagerCore();
/*
// enemyWaveManager.startWave(1); // Start with wave 1
*/
let gameStarted = false;

// Game simulation parameters
const PLAYER_SPEED = 200;
const BULLET_SPEED = 400;
const GAME_WIDTH = 800; // Assuming a game width
const GAME_HEIGHT = 600; // Assuming a game height
const SERVER_TICK_RATE = 1000 / 60; // approx 60Hz
let lastTickTime = Date.now();

// We no longer rely on a single main player for state
// let mainPlayerId = null;
// let latestAuthoritativeState = null; // State will be generated by the server loop

function getRandomColor() {
  const available = COLORS.filter(c => !usedColors.has(c));
  if (available.length === 0) return '#ffffff';
  const color = available[Math.floor(Math.random() * available.length)];
  usedColors.add(color);
  return color;
}

// Simple AABB collision check function (moved to global scope)
// Now accepts widths/heights explicitly
function aabbCollision(ax, ay, aw, ah, bx, by, bw, bh) {
  // Ensure all inputs are numbers before calculation
  if (typeof ax !== 'number' || typeof ay !== 'number' || typeof aw !== 'number' || typeof ah !== 'number' ||
      typeof bx !== 'number' || typeof by !== 'number' || typeof bw !== 'number' || typeof bh !== 'number') {
    console.error('[aabbCollision] Invalid input types received!');
    return false;
  }
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

// Gathers the current state to be broadcast
function gatherCurrentState() {
  const state = {
    players: {},
    playerBullets: playerBullets.map(b => ({ x: b.x, y: b.y, velocityY: b.velocityY, id: b.id, ownerId: b.ownerId })),
    enemyBullets: enemyBullets.map(b => ({ x: b.x, y: b.y, velocityX: b.velocityX, velocityY: b.velocityY, id: b.id, ownerId: b.ownerId })),
    enemies: enemyWaveManager.getEnemies(),
    waveNumber: enemyWaveManager.getWaveNumber(),
  };
  for (const id in players) {
    state.players[id] = {
      id: id,
      color: players[id].color,
      x: players[id].x,
      y: players[id].y,
      lives: players[id].lives,
    };
  }
  return state;
}

function broadcastState() {
  const state = gatherCurrentState();
  // console.log('[Server] Broadcasting authoritative_state:', JSON.stringify(state)); // Reduce logging noise
  const msg = JSON.stringify({ type: 'authoritative_state', ...state });
  wss.clients.forEach(client => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(msg);
    }
  });
}

// Resets the game state to initial values
function resetGameState() {
  console.log('[Server] Resetting game state...');
  // Reset player lives and positions (optional, or let client handle visual reset)
  for (const id in players) {
    players[id].lives = 3;
    players[id].x = 240; // Reset position
    players[id].y = 550;
    players[id].velocityX = 0;
    players[id].velocityY = 0;
    players[id].input = { left: false, right: false, up: false, down: false, fire: false };
    delete players[id].lastShotTime; // Reset shot cooldown
  }
  // Clear bullets
  playerBullets = [];
  enemyBullets = [];
  // Reset wave manager and start wave 1
  enemyWaveManager.startWave(1);
  // Ensure gameStarted allows the loop to run, but ready message might need re-evaluation if needed
  gameStarted = true; // Or false if we require 'ready' again? Let's keep it true for now.

  // Immediately broadcast the reset state
  broadcastState();
}

// Removed promoteNewMainPlayer - server is now authoritative

wss.on('connection', function connection(ws) {
  const id = uuidv4();
  const color = getRandomColor();
  // Initial player state
  players[id] = {
    ws,
    color,
    x: 240, // Start position consistent with client logs
    y: 550,
    lives: 3,
    velocityX: 0,
    velocityY: 0,
    lastInputTime: Date.now(),
    input: { left: false, right: false, up: false, down: false, fire: false } // Store last known input state
  };

  // No longer need to assign main player

  // Send player their ID and color
  ws.send(JSON.stringify({ type: 'welcome', id, color }));

  // On join, send the current authoritative state
  const currentState = gatherCurrentState();
  ws.send(JSON.stringify({ type: 'authoritative_state', ...currentState }));

  ws.on('message', function incoming(message) {
    let data;
    try {
      data = JSON.parse(message);
    } catch (e) {
      return;
    }

    // Handle player ready (welcome screen complete)
    if (data.type === 'ready' && !gameStarted) {
      enemyWaveManager.startWave(1);
      gameStarted = true;
    }

    // Handle player input
    if (data.type === 'input' && players[id]) {
      // console.log('[Server] Received input from player', id, data); // Reduce logging noise
      // Store the latest input state for this player
      players[id].input = {
        left: !!data.left,
        right: !!data.right,
        up: !!data.up,
        down: !!data.down,
        fire: !!data.fire,
      };
      players[id].lastInputTime = Date.now(); // Track when input was received

      // Handle firing immediately based on input
      // Handle firing based on input, using client-provided details if available
      if (data.fire) {
        const now = Date.now();
        // Use server-side cooldown check as the authority
        if (!players[id].lastShotTime || now - players[id].lastShotTime > 300) {
          let bulletId, bulletX, bulletY, bulletVelocityY;

          // Use client-provided details for the new bullet if available
          if (data.newBulletId && typeof data.newBulletX === 'number' && typeof data.newBulletY === 'number' && typeof data.newBulletVelocityY === 'number') {
            bulletId = data.newBulletId;
            bulletX = data.newBulletX;
            bulletY = data.newBulletY;
            bulletVelocityY = data.newBulletVelocityY;
            console.log(`[Server] Player ${id} firing confirmed bullet ${bulletId}`);
          } else {
            // Fallback if client didn't send bullet details (should not happen with updated client)
            console.warn(`[Server] Player ${id} fired but newBullet details missing in input. Generating fallback.`);
            bulletId = uuidv4(); // Generate server-side ID as fallback
            bulletX = players[id].x;
            bulletY = players[id].y - 20;
            bulletVelocityY = -BULLET_SPEED;
          }

          playerBullets.push({
            id: bulletId,
            ownerId: id,
            x: bulletX,
            y: bulletY,
            velocityY: bulletVelocityY,
          });
          players[id].lastShotTime = now; // Update cooldown server-side
        }
      }
    }
    // Removed enemyHit handler - collision is now server-authoritative

    // Handle game restart request
    if (data.type === 'requestRestart') {
      console.log(`[Server] Received requestRestart from player ${id}`);
      resetGameState();
    }
  });

  ws.on('close', function () {
    usedColors.delete(players[id].color);
    delete players[id];
    // No need to promote main player on disconnect
    // Optionally broadcast player disconnect
  });
});

// Server Game Loop
function updateGameState(playerWidth, playerHeight, enemyWidth, enemyHeight, bulletWidth, bulletHeight) {
  const now = Date.now();
  const delta = (now - lastTickTime) / 1000; // delta in seconds
  lastTickTime = now;

  // Update player positions based on last input
  for (const id in players) {
    const player = players[id];
    let targetVelocityX = 0;
    let targetVelocityY = 0;

    if (player.input.left) targetVelocityX = -PLAYER_SPEED;
    if (player.input.right) targetVelocityX = PLAYER_SPEED;
    if (player.input.up) targetVelocityY = -PLAYER_SPEED;
    if (player.input.down) targetVelocityY = PLAYER_SPEED;

    // Simple velocity update (could add smoothing/acceleration later)
    player.velocityX = targetVelocityX;
    player.velocityY = targetVelocityY;

    // Update position based on velocity and delta time
    player.x += player.velocityX * delta;
    player.y += player.velocityY * delta;

    // Clamp position to game bounds (adjust as needed)
    player.x = Math.max(0, Math.min(GAME_WIDTH, player.x));
    player.y = Math.max(0, Math.min(GAME_HEIGHT, player.y));
  }

  // Update player bullet positions
  const remainingBullets = [];
  for (const bullet of playerBullets) {
    bullet.y += bullet.velocityY * delta;
    // Keep bullet if it's within bounds
    if (bullet.y > 0 && bullet.y < GAME_HEIGHT) {
      remainingBullets.push(bullet);
    }
  }
  playerBullets = remainingBullets;

  // Update enemy positions
  enemyWaveManager.update(delta * 1000); // delta is in ms

  // --- Enemy Shooting Logic ---
  const ENEMY_BULLET_SPEED = 200;
  const ENEMY_SHOOT_INTERVAL = 1500; // ms, can randomize per enemy for variety
  const newEnemyBullets = [];
  const enemies = enemyWaveManager.getEnemies();
  for (const enemy of enemies) {
    // Use the visible flag from EnemyWaveManagerCore
    if (!enemy.active || !enemy.visible) continue;
    if (!enemy.lastShotTime) enemy.lastShotTime = now + Math.random() * ENEMY_SHOOT_INTERVAL; // randomize first shot

    // Determine shoot interval based on type (Falcons shoot less often)
    const shootInterval = enemy.type === 2 ? ENEMY_SHOOT_INTERVAL * 2 : ENEMY_SHOOT_INTERVAL;

    if (now - enemy.lastShotTime > shootInterval + Math.random() * 1000) {
      if (enemy.type === 1) { // Normal Enemy
        newEnemyBullets.push({
          id: `enemy_bullet_${enemy.id}_${now}`,
          ownerId: enemy.id,
          x: enemy.x,
          y: enemy.y + 20,
          velocityX: 0,
          velocityY: ENEMY_BULLET_SPEED
        });
      } else if (enemy.type === 2) { // Falcon Enemy
        const speed = ENEMY_BULLET_SPEED * 1.5; // Falcons shoot faster
        const spread = 12.5; // degrees from vertical
        const baseAngles = [90 - spread, 90 + spread]; // 77.5 and 102.5 degrees

        baseAngles.forEach((angle, index) => {
          const rad = angle * (Math.PI / 180); // Convert degrees to radians
          const vx = speed * Math.cos(rad);
          const vy = speed * Math.sin(rad);
          newEnemyBullets.push({
            id: `enemy_bullet_${enemy.id}_${now}_${index}`, // Ensure unique ID for split shot
            ownerId: enemy.id,
            x: enemy.x,
            y: enemy.y + 20,
            velocityX: vx,
            velocityY: vy
          });
        });
      }
      enemy.lastShotTime = now;
    }
  }
  enemyBullets.push(...newEnemyBullets);

  // Update enemy bullet positions
  const remainingEnemyBullets = [];
  for (const bullet of enemyBullets) {
    bullet.x += (bullet.velocityX || 0) * delta; // Add velocityX update
    bullet.y += bullet.velocityY * delta;
    // Add horizontal bounds check
    if (bullet.y > 0 && bullet.y < GAME_HEIGHT && bullet.x > 0 && bullet.x < GAME_WIDTH) {
      remainingEnemyBullets.push(bullet);
    }
  }
  enemyBullets = remainingEnemyBullets;

  // --- Player Bullet vs Enemy Collisions ---
  const activeEnemies = enemies.filter(e => e.active); // Use already fetched active enemies
  playerBullets.forEach(bullet => {
    if (bullet._remove) return; // Skip bullets already marked for removal

    for (const enemy of activeEnemies) {
      // Pass dimensions explicitly
      if (
        // Use passed-in dimensions
        aabbCollision(
          bullet.x - bulletWidth / 2, bullet.y - bulletHeight / 2, bulletWidth, bulletHeight,
          enemy.x - enemyWidth / 2, enemy.y - enemyHeight / 2, enemyWidth, enemyHeight
        )
      ) {
        console.log(`[Server] Collision! Bullet ${bullet.id} hit Enemy ${enemy.id}`);
        enemyWaveManager.destroyEnemyById(enemy.id); // Mark enemy as inactive
        bullet._remove = true; // Mark bullet for removal
        // Optionally: update score, trigger explosion effect state change, etc.
        break; // Bullet hits one enemy and is removed
      }
    }
  });
  // Remove player bullets marked for removal *after* checking all enemies
  playerBullets = playerBullets.filter(b => !b._remove);


  // --- Wave Progression ---
  const allEnemiesInactive = enemies.length > 0 && enemies.every(e => !e.active);
  if (allEnemiesInactive) {
    const nextWave = enemyWaveManager.getWaveNumber() + 1;
    enemyWaveManager.startWave(nextWave);
  }

  // --- Enemy-Player and Enemy-Bullet Collisions ---
  // aabbCollision function moved to global scope

  // Collision dimensions moved to global scope
  // Enemy bullet vs player
  for (const bullet of enemyBullets) {
    for (const id in players) {
      const player = players[id];
      if (player.lives <= 0) continue;
      // Pass dimensions explicitly
      // Use passed-in dimensions
      if (
        aabbCollision(
          bullet.x - bulletWidth / 2, bullet.y - bulletHeight / 2, bulletWidth, bulletHeight,
          player.x - playerWidth / 2, player.y - playerHeight / 2, playerWidth, playerHeight
        )
      ) {
        player.lives = Math.max(0, player.lives - 1);
        bullet._remove = true;
        // Optionally: respawn player, set invincibility, etc.
      }
    }
  }
  // Remove bullets marked for removal
  enemyBullets = enemyBullets.filter(b => !b._remove);

  // Enemy vs player
  for (const enemy of enemies) {
    if (!enemy.active) continue;
    for (const id in players) {
      const player = players[id];
      if (player.lives <= 0) continue;
      // Pass dimensions explicitly
      // Use passed-in dimensions
      if (
        aabbCollision(
          enemy.x - enemyWidth / 2, enemy.y - enemyHeight / 2, enemyWidth, enemyHeight,
          player.x - playerWidth / 2, player.y - playerHeight / 2, playerWidth, playerHeight
        )
      ) {
        player.lives = Math.max(0, player.lives - 1);
        // Optionally: respawn player, set invincibility, etc.
      }
    }
  }

  // Broadcast the updated state
  broadcastState();
}

// Start the game loop
setInterval(() => {
  updateGameState(PLAYER_WIDTH, PLAYER_HEIGHT, ENEMY_WIDTH, ENEMY_HEIGHT, BULLET_WIDTH, BULLET_HEIGHT);
}, SERVER_TICK_RATE);

console.log(`Multiplayer server running on ws://localhost:${PORT}`);