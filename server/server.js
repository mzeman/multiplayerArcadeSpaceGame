// Multiplayer Game Server (WebSocket)
// Run with: node server/server.js

const WebSocket = require('ws');
const { v4: uuidv4 } = require('uuid');

const path = require('path');
const { EnemyWaveManagerCore } = require(path.resolve(__dirname, '../dist/shared/EnemyWaveManagerCore.js'));
const PORT = 3001;
const wss = new WebSocket.Server({ port: PORT });

// Collision dimensions (moved to top-level global scope)
const PLAYER_WIDTH = 40, PLAYER_HEIGHT = 40;
const ENEMY_WIDTH = 40, ENEMY_HEIGHT = 40;
const BULLET_WIDTH = 8, BULLET_HEIGHT = 16;

const COLORS = [
  '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231',
  '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe',
  '#008080', '#e6beff', '#9a6324', '#fffac8', '#800000',
  '#aaffc3', '#808000', '#ffd8b1', '#000075', '#808080'
];

let players = {}; // id: { ws, color, x, y, lives, velocityX, velocityY, lastInputTime, input: { left, right, up, down, fire } }
let playerBullets = []; // { id, x, y, velocityY, ownerId }
let enemyBullets = []; // { id, x, y, velocityX, velocityY, ownerId: 'enemy_<id>' }
let usedColors = new Set();
const enemyWaveManager = new EnemyWaveManagerCore();
let lastFireTimePerType = {}; // Tracks the last time an enemy of a specific type fired
/*
// enemyWaveManager.startWave(1); // Start with wave 1
*/
let gameStarted = false;
let overallGameState = 'playing'; // 'playing' or 'gameOver'

// Game simulation parameters
const PLAYER_SPEED = 200;
const BULLET_SPEED = 400;
const GAME_WIDTH = 1024; // Assuming a game width
const GAME_HEIGHT = 768; // Assuming a game height
const SERVER_TICK_RATE = 1000 / 60; // approx 60Hz
let lastTickTime = Date.now();

// We no longer rely on a single main player for state
// let mainPlayerId = null;
// let latestAuthoritativeState = null; // State will be generated by the server loop

function getRandomColor() {
  const available = COLORS.filter(c => !usedColors.has(c));
  if (available.length === 0) return '#ffffff';
  const color = available[Math.floor(Math.random() * available.length)];
  usedColors.add(color);
  return color;
}

// Simple AABB collision check function (moved to global scope)
// Now accepts widths/heights explicitly
function aabbCollision(ax, ay, aw, ah, bx, by, bw, bh) {
  // Ensure all inputs are numbers before calculation
  if (typeof ax !== 'number' || typeof ay !== 'number' || typeof aw !== 'number' || typeof ah !== 'number' ||
      typeof bx !== 'number' || typeof by !== 'number' || typeof bw !== 'number' || typeof bh !== 'number') {
    console.error('[aabbCollision] Invalid input types received!');
    return false;
  }
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

// Gathers the current state to be broadcast
function gatherCurrentState() {
  const state = {
    players: {},
    playerBullets: playerBullets.map(b => ({ x: b.x, y: b.y, velocityY: b.velocityY, id: b.id, ownerId: b.ownerId })),
    // Include bulletType for enemy bullets
    enemyBullets: enemyBullets.map(b => ({ x: b.x, y: b.y, velocityX: b.velocityX, velocityY: b.velocityY, id: b.id, ownerId: b.ownerId, bulletType: b.bulletType })),
    enemies: enemyWaveManager.getEnemies(),
    waveNumber: enemyWaveManager.getWaveNumber(),
    gameState: overallGameState, // Include overall game state
  };
  for (const id in players) {
    state.players[id] = {
      id: id,
      color: players[id].color,
      x: players[id].x,
      y: players[id].y,
      lives: players[id].lives,
      isInvincible: players[id].isInvincible || false, // Include invincibility status
      isActive: players[id].isActive, // Include active status
    };
  }
  return state;
}

function broadcastState() {
  const state = gatherCurrentState();
  // console.log('[Server] Broadcasting authoritative_state:', JSON.stringify(state)); // Reduce logging noise
  const msg = JSON.stringify({ type: 'authoritative_state', ...state });
  wss.clients.forEach(client => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(msg);
    }
  });
}

// Resets the game state to initial values
function resetGameState() {
  console.log('[Server] Resetting game state...');
  // Reset player lives and positions (optional, or let client handle visual reset)
  for (const id in players) {
    players[id].lives = 3;
    players[id].x = 240; // Reset position
    players[id].y = 550;
    players[id].velocityX = 0;
    players[id].velocityY = 0;
    players[id].input = { left: false, right: false, up: false, down: false, fire: false };
    delete players[id].lastShotTime; // Reset shot cooldown
    players[id].isActive = true; // Reset active status
    console.log(`[Reset Debug] Setting player ${id} isActive to true.`); // Added log
  }
  overallGameState = 'playing'; // Reset overall game state
  // Clear bullets
  playerBullets = [];
  enemyBullets = [];
  // Reset wave manager and start wave 1
  enemyWaveManager.startWave(1);
  // Ensure gameStarted allows the loop to run, but ready message might need re-evaluation if needed
  gameStarted = true; // Or false if we require 'ready' again? Let's keep it true for now.

  // Immediately broadcast the reset state
  // Added logs before broadcasting reset state
  const playersStateForLog = {};
  for (const id in players) {
      playersStateForLog[id] = { lives: players[id].lives, isActive: players[id].isActive };
  }
  console.log('[Reset Debug] Broadcasting reset state with players:', JSON.stringify(playersStateForLog));
  broadcastState();
}

// Removed promoteNewMainPlayer - server is now authoritative

wss.on('connection', function connection(ws) {
  const id = uuidv4();
  const color = getRandomColor();
  // Initial player state
  players[id] = {
    ws,
    color,
    x: 240, // Start position consistent with client logs
    y: 550,
    lives: 3,
    velocityX: 0,
    velocityY: 0,
    lastInputTime: Date.now(),
    input: { left: false, right: false, up: false, down: false, fire: false }, // Store last known input state
    isInvincible: false, // Add invincibility state
    invincibleUntil: 0,  // Timestamp until invincibility lasts
    isActive: true,      // Add active status
    lastEnemyCollisionTime: 0 // Timestamp for enemy collision cooldown
  };

  // No longer need to assign main player

  // Send player their ID and color
  ws.send(JSON.stringify({ type: 'welcome', id, color }));

  // On join, send the current authoritative state
  const currentState = gatherCurrentState();
  ws.send(JSON.stringify({ type: 'authoritative_state', ...currentState }));
  // Also broadcast the updated state to all existing clients
  console.log(`[Server] Broadcasting state to all clients after new player ${id} joined.`);
  broadcastState();

  ws.on('message', function incoming(message) {
    let data;
    try {
      data = JSON.parse(message);
    } catch (e) {
      return;
    }

    // Handle player ready (welcome screen complete)
    if (data.type === 'ready' && !gameStarted) {
      enemyWaveManager.startWave(1);
      gameStarted = true;
    }

    // Handle player input
    // Process input only if player exists and is active
    if (data.type === 'input' && players[id] && players[id].isActive) {
      // console.log('[Server] Received input from active player', id, data); // Reduce logging noise
      // Store the latest input state for this player
      players[id].input = {
        left: !!data.left,
        right: !!data.right,
        up: !!data.up,
        down: !!data.down,
        fire: !!data.fire,
      };
      players[id].lastInputTime = Date.now(); // Track when input was received

      // Handle firing immediately based on input
      if (data.fire) {
        const now = Date.now();
        // Use server-side cooldown check as the authority
        if (!players[id].lastShotTime || now - players[id].lastShotTime > 300) {
          let bulletId, bulletX, bulletY, bulletVelocityY;

          // Use client-provided details for the new bullet if available
          if (data.newBulletId && typeof data.newBulletX === 'number' && typeof data.newBulletY === 'number' && typeof data.newBulletVelocityY === 'number') {
            bulletId = data.newBulletId;
            bulletX = data.newBulletX;
            bulletY = data.newBulletY;
            bulletVelocityY = data.newBulletVelocityY;
            // console.log(`[Server] Player ${id} firing confirmed bullet ${bulletId}`); // Reduce noise
          } else {
            // Fallback if client didn't send bullet details
            console.warn(`[Server] Player ${id} fired but newBullet details missing. Generating fallback.`);
            bulletId = uuidv4();
            bulletX = players[id].x;
            bulletY = players[id].y - 20;
            bulletVelocityY = -BULLET_SPEED;
          }

          playerBullets.push({
            id: bulletId,
            ownerId: id,
            x: bulletX,
            y: bulletY,
            velocityY: bulletVelocityY,
          });
          players[id].lastShotTime = now; // Update cooldown server-side
        }
      }
    } else if (data.type === 'input' && players[id] && !players[id].isActive) {
      // Optionally log ignored input from inactive player
      // console.log(`[Server] Ignored input from inactive player ${id}`);
    }
    // Removed enemyHit handler - collision is now server-authoritative

    // Handle game restart request
    if (data.type === 'requestRestart') {
      console.log(`[Server] Received requestRestart from player ${id}`);
      resetGameState();
    }

    // Handle invincibility toggle request only if player exists and is active
    if (data.type === 'toggleInvincible' && players[id] && players[id].isActive) {
      const now = Date.now();
      // Toggle the invincibility state
      players[id].isInvincible = !players[id].isInvincible;
      players[id].invincibleUntil = 0; // Clear any previous timer value
      console.log(`[Server] Player ${id} toggled invincibility to: ${players[id].isInvincible}`);
      }
      // Note: We don't handle toggling *off* via message here, only expiration or reset
    else if (data.type === 'toggleInvincible' && players[id] && !players[id].isActive) {
       // console.log(`[Server] Ignored invincibility toggle from inactive player ${id}`);
    }
  });

  ws.on('close', function () {
    usedColors.delete(players[id].color);
    delete players[id];
    // No need to promote main player on disconnect
    // Optionally broadcast player disconnect
  });
});

// Server Game Loop
function updateGameState(playerWidth, playerHeight, enemyWidth, enemyHeight, bulletWidth, bulletHeight) {
  const now = Date.now();
  const delta = (now - lastTickTime) / 1000; // delta in seconds
  lastTickTime = now;

  // Update player positions based on last input
  for (const id in players) {
    const player = players[id];
    let targetVelocityX = 0;
    let targetVelocityY = 0;

    if (player.input.left) targetVelocityX = -PLAYER_SPEED;
    if (player.input.right) targetVelocityX = PLAYER_SPEED;
    if (player.input.up) targetVelocityY = -PLAYER_SPEED;
    if (player.input.down) targetVelocityY = PLAYER_SPEED;

    // Simple velocity update (could add smoothing/acceleration later)
    player.velocityX = targetVelocityX;
    player.velocityY = targetVelocityY;

    // Update position based on velocity and delta time
    player.x += player.velocityX * delta;
    player.y += player.velocityY * delta;

    // Clamp position to game bounds (adjust as needed)
    player.x = Math.max(0, Math.min(GAME_WIDTH, player.x));
    player.y = Math.max(0, Math.min(GAME_HEIGHT, player.y));
  }

  // Check for invincibility expiration

  // Update player bullet positions
  const remainingBullets = [];
  for (const bullet of playerBullets) {
    bullet.y += bullet.velocityY * delta;
    // Keep bullet if it's within bounds
    if (bullet.y > 0 && bullet.y < GAME_HEIGHT) {
      remainingBullets.push(bullet);
    }
  }
  playerBullets = remainingBullets;

  // Update enemy positions
  enemyWaveManager.update(delta * 1000, GAME_HEIGHT); // Pass game height


  // --- Enemy Shooting Logic ---
  const ENEMY_BULLET_SPEED = 200;
  const ENEMY_SHOOT_INTERVAL = 1500; // ms, can randomize per enemy for variety
  const newEnemyBullets = [];
  const enemies = enemyWaveManager.getEnemies();
  for (const enemy of enemies) {
    // Use the visible flag from EnemyWaveManagerCore
    if (!enemy.active || !enemy.visible) continue;
    if (!enemy.lastShotTime) enemy.lastShotTime = now + Math.random() * ENEMY_SHOOT_INTERVAL; // randomize first shot

    // Determine shoot interval based on type (Falcons shoot less often)
    const shootInterval = enemy.type === 2 ? ENEMY_SHOOT_INTERVAL * 2 : ENEMY_SHOOT_INTERVAL;

    // Check type-based cooldown first (1 second)
    const typeCooldownReady = now - (lastFireTimePerType[enemy.type] || 0) > 1000;

    if (typeCooldownReady && now - enemy.lastShotTime > shootInterval + Math.random() * 1000) {
      let fired = false; // Flag to track if this enemy fired in this tick
      if (enemy.type === 1) { // Normal Enemy
        newEnemyBullets.push({
          id: `enemy_bullet_${enemy.id}_${now}`,
          ownerId: enemy.id,
          x: enemy.x,
          y: enemy.y + 20,
          velocityX: 0,
          velocityY: ENEMY_BULLET_SPEED,
          bulletType: 'normal' // Add bullet type
        });
        fired = true;
      } else if (enemy.type === 2) { // Falcon Enemy
        const speed = ENEMY_BULLET_SPEED * 1.5; // Falcons shoot faster
        const spread = 12.5; // degrees from vertical
        const baseAngles = [90 - spread, 90 + spread]; // 77.5 and 102.5 degrees

        baseAngles.forEach((angle, index) => {
          const rad = angle * (Math.PI / 180); // Convert degrees to radians
          const vx = speed * Math.cos(rad);
          const vy = speed * Math.sin(rad);
          newEnemyBullets.push({
            id: `enemy_bullet_${enemy.id}_${now}_${index}`, // Ensure unique ID for split shot
            ownerId: enemy.id,
            x: enemy.x,
            y: enemy.y + 20,
            velocityX: vx,
            velocityY: vy,
            bulletType: 'falcon' // Add bullet type
          });
        });
        fired = true;
      }

      if (fired) {
        enemy.lastShotTime = now; // Update individual cooldown
        lastFireTimePerType[enemy.type] = now; // Update type-based cooldown
      }
    }
  }
  enemyBullets.push(...newEnemyBullets);

  // Update enemy bullet positions
  const remainingEnemyBullets = [];
  for (const bullet of enemyBullets) {
    bullet.x += (bullet.velocityX || 0) * delta; // Add velocityX update
    bullet.y += bullet.velocityY * delta;
    // Add horizontal bounds check
    if (bullet.y > 0 && bullet.y < GAME_HEIGHT && bullet.x > 0 && bullet.x < GAME_WIDTH) {
      remainingEnemyBullets.push(bullet);
    }
  }
  enemyBullets = remainingEnemyBullets;

  // --- Player Bullet vs Enemy Collisions ---
  const activeEnemies = enemies.filter(e => e.active); // Use already fetched active enemies
  playerBullets.forEach(bullet => {
    if (bullet._remove) return; // Skip bullets already marked for removal

    for (const enemy of activeEnemies) {
      // Pass dimensions explicitly
      if (
        // Use passed-in dimensions
        aabbCollision(
          bullet.x - bulletWidth / 2, bullet.y - bulletHeight / 2, bulletWidth, bulletHeight,
          enemy.x - enemyWidth / 2, enemy.y - enemyHeight / 2, enemyWidth, enemyHeight
        )
      ) {
        console.log(`[Server] Collision! Bullet ${bullet.id} hit Enemy ${enemy.id}`);
        enemyWaveManager.destroyEnemyById(enemy.id); // Mark enemy as inactive
        bullet._remove = true; // Mark bullet for removal
        // Optionally: update score, trigger explosion effect state change, etc.
        break; // Bullet hits one enemy and is removed
      }
    }
  });
  // Remove player bullets marked for removal *after* checking all enemies
  playerBullets = playerBullets.filter(b => !b._remove);



  // --- Enemy-Player and Enemy-Bullet Collisions ---
  // aabbCollision function moved to global scope

  // Collision dimensions moved to global scope
  // Enemy bullet vs player
  for (const bullet of enemyBullets) {
    for (const id in players) {
      const player = players[id];
      if (player.lives <= 0) continue;
      // Pass dimensions explicitly
      // Use passed-in dimensions
      if (
        aabbCollision(
          bullet.x - bulletWidth / 2, bullet.y - bulletHeight / 2, bulletWidth, bulletHeight,
          player.x - playerWidth / 2, player.y - playerHeight / 2, playerWidth, playerHeight
        )
      ) {
        // Apply damage only if player is not invincible
        if (!player.isInvincible) {
          player.lives = Math.max(0, player.lives - 1);
          player.isActive = player.lives > 0; // Update active status immediately
          console.log(`[Server] Player ${id} hit by bullet ${bullet.id}. Lives left: ${player.lives}. Active: ${player.isActive}`);
        } else {
          console.log(`[Server] Player ${id} invincible, blocked bullet ${bullet.id}`);
        }
        bullet._remove = true; // Remove bullet regardless of invincibility
      }
    }
  }
  // Remove bullets marked for removal
  enemyBullets = enemyBullets.filter(b => !b._remove);

  // Enemy vs player
  for (const enemy of enemies) {
    if (!enemy.active) continue;
    for (const id in players) {
      const player = players[id];
      if (player.lives <= 0) continue;
      // Pass dimensions explicitly
      // Use passed-in dimensions
      if (
        aabbCollision(
          enemy.x - enemyWidth / 2, enemy.y - enemyHeight / 2, enemyWidth, enemyHeight,
          player.x - playerWidth / 2, player.y - playerHeight / 2, playerWidth, playerHeight
        )
      ) {
        // Check cooldown (500ms) before applying damage from enemy collision
        const cooldown = 500;
        if (now - (player.lastEnemyCollisionTime || 0) > cooldown) {
          // Apply damage only if player is not invincible
          if (!player.isInvincible) {
            player.lives = Math.max(0, player.lives - 1);
            player.isActive = player.lives > 0; // Update active status immediately
            player.lastEnemyCollisionTime = now; // Update timestamp after applying damage
            console.log(`[Server] Player ${id} collided with enemy ${enemy.id}. Lives left: ${player.lives}. Active: ${player.isActive}`);
            // Note: Enemy is not destroyed by player collision
          } else {
             console.log(`[Server] Player ${id} invincible, blocked collision with enemy ${enemy.id}`);
          }
        } // else: Cooldown active, ignore collision damage
      }
    }
  }

  // --- Check for Game Over Condition (All Players Inactive) --- MOVED EARLIER
  // This check runs after collisions update lives/active status
  if (overallGameState === 'playing') {
      const activePlayers = Object.values(players).filter(p => p.isActive);
      // Ensure there are players connected before declaring game over based on lives
      if (Object.keys(players).length > 0 && activePlayers.length === 0) {
          // --- Add Detailed Logging Before Game Over ---
          const playerStatesForLog = Object.entries(players).map(([id, p]) => ({ id, lives: p.lives, isActive: p.isActive }));
          console.log("[Server Game Over Check] All players inactive condition met. Player States:", JSON.stringify(playerStatesForLog));
          // --- End Detailed Logging ---
          console.log("[Server] All players inactive (lives=0). Setting game state to gameOver.");
          overallGameState = 'gameOver';
          // If game over is set here, broadcast and return to avoid further checks in this tick
          broadcastState();
          return;
      }
  }

  // --- Check for Enemies Reaching Bottom & Player Invincibility --- MOVED LATER
  // This check only runs if the game wasn't already ended by the 'All Players Inactive' check
  if (overallGameState === 'playing') {
    let enemyReachedBottomAndGameOver = false; // Flag to signal game over from this specific check
    const currentEnemiesForBottomCheck = enemyWaveManager.getEnemies(); // Get potentially updated enemies
    for (const enemy of currentEnemiesForBottomCheck) {
      // Check only active enemies
      if (enemy.active && enemy.y >= GAME_HEIGHT) { // Use GAME_HEIGHT constant
        // Enemy reached bottom, now check player invincibility
        let allActivePlayersInvincible = false;
        const activePlayerIds = Object.keys(players).filter(id => players[id].isActive);

        // Check if there are active players and if all of them are invincible
        if (activePlayerIds.length > 0 && activePlayerIds.every(id => players[id].isInvincible === true)) {
          allActivePlayersInvincible = true;
        }

        if (allActivePlayersInvincible) {
          // Reset wave position because all active players are invincible
          console.log('[Server] Enemy reached bottom, but all active players invincible. Resetting wave position.');
          enemyWaveManager.resetActiveEnemyPositions(); // Reset positions to their original startX/startY
          // Break the loop, wave is reset, continue the game loop
          break;
        } else {
          // Enemy reached bottom and NOT all active players are invincible - Game Over
          console.log('[Server] Enemy reached bottom. Game Over.');
          overallGameState = 'gameOver';
          enemyReachedBottomAndGameOver = true; // Signal that game ended here
          // Break the loop, game is over
          break;
        }
      }
    }
    // If game ended due to enemy reaching bottom, broadcast and exit early
    if (enemyReachedBottomAndGameOver) {
      broadcastState();
      return; // Stop updateGameState for this tick
    }
  }
  // --- End Enemy Reaching Bottom Check ---

  // --- Wave Progression --- MOVED LATER
  // Check wave progression only if the game is still playing
  if (overallGameState === 'playing') {
      // Fetch enemies again in case their state changed (e.g., reset positions)
      const currentEnemiesForWaveCheck = enemyWaveManager.getEnemies();
      const allEnemiesInactive = currentEnemiesForWaveCheck.length > 0 && currentEnemiesForWaveCheck.every(e => !e.active);
      if (allEnemiesInactive) {
          const nextWave = enemyWaveManager.getWaveNumber() + 1;
          console.log(`[Server] All enemies inactive. Starting wave ${nextWave}`);
          enemyWaveManager.startWave(nextWave);
      }
  }

  // Broadcast the updated state
  broadcastState();
}

// Start the game loop
setInterval(() => {
  updateGameState(PLAYER_WIDTH, PLAYER_HEIGHT, ENEMY_WIDTH, ENEMY_HEIGHT, BULLET_WIDTH, BULLET_HEIGHT);
}, SERVER_TICK_RATE);

console.log(`Multiplayer server running on ws://localhost:${PORT}`);